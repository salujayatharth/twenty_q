class TwentyQuestionsGame {
    constructor() {
        this.questionsRemaining = 20;
        this.gameActive = false;
        this.currentQuestion = '';
        this.gameHistory = [];
        this.questions = this.getDefaultQuestions();
        this.currentQuestionIndex = 0;
        
        this.initializeElements();
        this.bindEvents();
    }

    initializeElements() {
        this.startBtn = document.getElementById('start-btn');
        this.restartBtn = document.getElementById('restart-btn');
        this.gameControls = document.getElementById('game-controls');
        this.answerControls = document.getElementById('answer-controls');
        this.chatContainer = document.getElementById('chat-container');
        this.questionsLeftSpan = document.getElementById('questions-left');
        this.gameStatusSpan = document.getElementById('game-status');
        this.currentQuestionP = document.getElementById('current-question');
        this.funkyCounter = document.getElementById('counter-number');
    }

    bindEvents() {
        this.startBtn.addEventListener('click', () => this.startGame());
        this.restartBtn.addEventListener('click', () => this.restartGame());
    }

    getDefaultQuestions() {
        // A set of intelligent questions for the 20 questions game
        // In a real implementation, this would be generated by an LLM
        return [
            "Is it a living thing?",
            "Is it bigger than a car?",
            "Can you hold it in your hand?",
            "Is it found indoors?",
            "Is it made by humans?",
            "Does it move on its own?",
            "Is it used for entertainment?",
            "Is it electronic?",
            "Can you eat it?",
            "Is it made of metal?",
            "Does it have wheels?",
            "Is it something you wear?",
            "Does it grow in nature?",
            "Is it used for work or business?",
            "Does it make sounds?",
            "Is it colorful?",
            "Can it fly?",
            "Is it found in a kitchen?",
            "Does it require electricity?",
            "Is it something children use?"
        ];
    }

    startGame() {
        this.gameActive = true;
        this.questionsRemaining = 20;
        this.currentQuestionIndex = 0;
        this.gameHistory = [];
        
        this.updateDisplay();
        this.clearChat();
        this.addSystemMessage("Game started! I'm thinking of my first question...");
        
        // Show first question after a short delay
        setTimeout(() => {
            this.askNextQuestion();
        }, 1500);
    }

    restartGame() {
        this.gameActive = false;
        this.questionsRemaining = 20;
        this.currentQuestionIndex = 0;
        this.gameHistory = [];
        
        this.updateDisplay();
        this.clearChat();
        this.addWelcomeMessage();
    }

    askNextQuestion() {
        if (this.questionsRemaining <= 0 || this.currentQuestionIndex >= this.questions.length) {
            this.endGame(false);
            return;
        }

        // In a real implementation, this would call an LLM API
        // For now, we use our predefined questions with some intelligence
        const question = this.getNextIntelligentQuestion();
        this.currentQuestion = question;
        
        this.addAIMessage(question);
        this.currentQuestionP.textContent = question;
        this.updateDisplay();
        
        // Ensure scroll after all DOM updates
        requestAnimationFrame(() => {
            this.scrollToBottom();
        });
    }

    getNextIntelligentQuestion() {
        // Simple logic to pick questions based on previous answers
        // In a real LLM implementation, this would be much more sophisticated
        if (this.currentQuestionIndex < this.questions.length) {
            return this.questions[this.currentQuestionIndex];
        }
        
        // Fallback questions if we run out
        const fallbackQuestions = [
            "Is it commonly found in homes?",
            "Would most people recognize it?",
            "Is it expensive?",
            "Has it been invented in the last 100 years?"
        ];
        
        const fallbackIndex = (this.currentQuestionIndex - this.questions.length) % fallbackQuestions.length;
        return fallbackQuestions[fallbackIndex];
    }

    answerQuestion(answer) {
        if (!this.gameActive) return;

        this.addUserMessage(answer.toUpperCase());
        this.gameHistory.push({
            question: this.currentQuestion,
            answer: answer
        });

        this.questionsRemaining--;
        this.currentQuestionIndex++;

        // Simple guess logic - in a real implementation, this would use LLM reasoning
        if (this.shouldMakeGuess()) {
            this.makeGuess();
        } else if (this.questionsRemaining <= 0) {
            this.endGame(false);
        } else {
            // Ask next question after a short delay
            this.addSystemMessage("Thinking...");
            setTimeout(() => {
                this.askNextQuestion();
                // Ensure scroll after async question asking
                this.scrollToBottom();
            }, 2000);
        }

        this.updateDisplay();
        // Ensure we scroll to bottom after all DOM operations are complete
        requestAnimationFrame(() => {
            this.scrollToBottom();
        });
    }

    shouldMakeGuess() {
        // Simple heuristic: make a guess if we're running low on questions
        // or if we have enough information (simplified logic)
        return this.questionsRemaining <= 3 || this.gameHistory.length >= 10;
    }

    makeGuess() {
        // In a real implementation, this would use LLM to make an intelligent guess
        // For now, we'll make some simple guesses based on common answers
        const guesses = [
            "a smartphone",
            "a book",
            "a car",
            "a computer",
            "a dog",
            "a tree",
            "a chair",
            "pizza",
            "a television",
            "a guitar"
        ];

        const guess = guesses[Math.floor(Math.random() * guesses.length)];
        this.addAIMessage(`I think I know! Is it ${guess}?`);
        this.currentQuestionP.textContent = `Is it ${guess}?`;
        
        // Create special guess controls
        this.createGuessControls();
        
        // Ensure scroll after DOM modifications
        requestAnimationFrame(() => {
            this.scrollToBottom();
        });
    }

    createGuessControls() {
        const answerControls = document.getElementById('answer-controls');
        answerControls.innerHTML = `
            <p class="current-question">Is my guess correct?</p>
            <div class="answer-buttons">
                <button class="btn btn-yes" onclick="game.handleGuessResult(true)">Yes! You got it!</button>
                <button class="btn btn-no" onclick="game.handleGuessResult(false)">No, keep trying</button>
            </div>
        `;
    }

    handleGuessResult(correct) {
        if (correct) {
            this.addUserMessage("Yes! You got it!");
            this.endGame(true);
        } else {
            this.addUserMessage("No, that's not it");
            if (this.questionsRemaining <= 0) {
                this.endGame(false);
            } else {
                setTimeout(() => {
                    this.askNextQuestion();
                    // Ensure scroll after async question asking
                    this.scrollToBottom();
                }, 1500);
            }
        }
        // Ensure we scroll to bottom after all DOM operations are complete
        requestAnimationFrame(() => {
            this.scrollToBottom();
        });
    }

    endGame(won) {
        this.gameActive = false;
        
        if (won) {
            this.addSystemMessage("ðŸŽ‰ I won! Thanks for playing!");
            this.gameStatusSpan.textContent = "Game Over - AI Wins!";
        } else {
            this.addSystemMessage("ðŸ¤” I couldn't guess it! You win this round. What were you thinking of?");
            this.gameStatusSpan.textContent = "Game Over - You Win!";
        }

        this.showGameControls();
    }

    addAIMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message ai-message';
        messageDiv.textContent = `ðŸ¤– ${message}`;
        this.chatContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }

    addUserMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message user-message';
        messageDiv.textContent = `You: ${message}`;
        this.chatContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }

    addSystemMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message system-message';
        messageDiv.textContent = message;
        this.chatContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }

    clearChat() {
        this.chatContainer.innerHTML = '';
    }

    addWelcomeMessage() {
        this.chatContainer.innerHTML = `
            <div class="welcome-message">
                <p>Welcome to Twenty Questions!</p>
                <p>Think of any object, person, place, or concept, then click "Start Game" to begin.</p>
            </div>
        `;
    }

    isScrolledToBottom() {
        const threshold = 5; // Small threshold to account for rounding errors
        // If content doesn't exceed container height, we're always considered "at bottom"
        if (this.chatContainer.scrollHeight <= this.chatContainer.clientHeight) {
            return true;
        }
        return this.chatContainer.scrollTop + this.chatContainer.clientHeight >= 
               this.chatContainer.scrollHeight - threshold;
    }

    scrollToBottom() {
        // Only auto-scroll if user is already at or near the bottom
        if (this.isScrolledToBottom()) {
            this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
        }
    }

    forceScrollToBottom() {
        // Force scroll to bottom regardless of current position
        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
    }

    updateDisplay() {
        this.questionsLeftSpan.textContent = this.questionsRemaining;
        
        // Update funky counter to show questions asked (20 - remaining)
        const questionsAsked = 20 - this.questionsRemaining;
        this.funkyCounter.textContent = questionsAsked;
        
        if (this.gameActive) {
            this.gameStatusSpan.textContent = "Game in progress...";
            this.showAnswerControls();
        } else {
            this.showGameControls();
        }
    }

    showGameControls() {
        this.gameControls.style.display = 'block';
        this.answerControls.style.display = 'none';
        this.startBtn.style.display = 'inline-block';
        this.restartBtn.style.display = 'inline-block';
    }

    showAnswerControls() {
        this.gameControls.style.display = 'none';
        this.answerControls.style.display = 'block';
        
        // Restore default answer controls if they were modified for guessing
        if (!this.answerControls.innerHTML.includes('btn-maybe')) {
            this.answerControls.innerHTML = `
                <p class="current-question" id="current-question">${this.currentQuestion}</p>
                <div class="answer-buttons">
                    <button class="btn btn-yes" onclick="answerQuestion('yes')">Yes</button>
                    <button class="btn btn-no" onclick="answerQuestion('no')">No</button>
                    <button class="btn btn-maybe" onclick="answerQuestion('maybe')">Maybe</button>
                </div>
            `;
        }
    }
}

// Global functions for button clicks
function answerQuestion(answer) {
    game.answerQuestion(answer);
}

// Initialize the game when the page loads
let game;
document.addEventListener('DOMContentLoaded', function() {
    game = new TwentyQuestionsGame();
});

// LLM Integration placeholder
// In a real implementation, you would add API calls here
class LLMIntegration {
    constructor(apiKey, provider = 'openai') {
        this.apiKey = apiKey;
        this.provider = provider;
    }

    async generateQuestion(gameHistory) {
        // Placeholder for LLM API call
        // This would send the game history to an LLM and get a smart question back
        console.log('LLM Integration: Generate question based on history:', gameHistory);
        
        // For now, return a placeholder
        return "This would be an AI-generated question based on previous answers";
    }

    async makeGuess(gameHistory) {
        // Placeholder for LLM API call
        // This would analyze all answers and make an intelligent guess
        console.log('LLM Integration: Make guess based on history:', gameHistory);
        
        // For now, return a placeholder
        return "This would be an AI-generated guess";
    }
}

// Load configuration with environment variable support
function loadConfiguration() {
    // Try to load config.js if it exists (browser environment)
    if (typeof window !== 'undefined') {
        // In browser, config should be loaded via script tag or other means
        return typeof gameConfiguration !== 'undefined' ? gameConfiguration : null;
    }
    
    // In Node.js environment, try to require config
    try {
        if (typeof require !== 'undefined') {
            return require('./config.js');
        }
    } catch (e) {
        // Fallback to example config structure with environment variable
        return {
            llm: {
                provider: 'openai',
                apiKey: (typeof process !== 'undefined' && process.env && process.env.OPENAI_API_KEY) || 'your-api-key-here',
                model: 'gpt-3.5-turbo'
            }
        };
    }
    
    return null;
}

// Initialize LLM integration if configuration is available
let llm = null;
const config = loadConfiguration();
if (config && config.llm && config.llm.apiKey && config.llm.apiKey !== 'your-api-key-here') {
    llm = new LLMIntegration(config.llm.apiKey, config.llm.provider);
}